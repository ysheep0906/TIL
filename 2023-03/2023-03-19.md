# [TIL] 2023-03-19
- 알고리즘 공부

## 피보나찌 수 구하기(재귀)
```python
def fib(n):
  if(n <=1):
    return n
  else:
    return fib(n-1) + fib(n-2)
```
재귀 알고리즘은 수행속도가 매우 느리다.<br>
같은 피보나찌 수를 중복 계산하기 때문이다.<br>
ex) fib(5) 계산에 fib(2) 3번 중복 계산<br><br>

### fib(n)의 함수 호출 횟수 계산
T(n)은 fib(n)을 계산하기 위하여 fib 함수를 호출하는 횟수
```
T(0) = 1
T(1) = 1
T(n) = T(n - 1) + T(n - 2) + 1 / for n ≥ 2, n이 짝수 가정
> 2 X T(n - 2) 왜냐하면 T(n - 1) > T(n - 2)
> 2^2 X T(n - 4) 왜냐하면 T(n - 2) > 2 X T(n - 4)
> 2^3 X T(n - 6)
...
> 2^(n/2) X T(0)
= 2^(n/2)

n 이 홀수일 때도 유사하게 증명 가능
```

## 피보나찌 수 구하기(반복)
```python
def fib2(n):
  f = [0 for _ in range(n)]
  f[0] = 0
  if(n > 0):
    f[1] = 1
    for i in range(2,n+1):
      f[i] = f[i-1] + f[i-2]
  return f[n-1]
```
반복 알고리즘은 수행속도가 훨씬 더 빠르다(중복계산이 없음)<br>
- 계산하는 항의 총 개수<br>
T(n) = n + 1<br>
즉, f[0]부터 f[n]까지 한번 씩만 계산

## 알고리즘의 분석
- 공간복잡도 분석<br>
`입력 크기`에 따라서 작업공간(`메모리`)이 얼마나 필요한 지 결정하는 절차<br>
- 시간복잡도 분석<br>
`입력 크기`에 따라서 `단위 연산`이 몇 번 수행되는지 결정하는 절차

## 분석 방법의 종류
- 모든 경우 분석(Every-case analysis)<br>
입력 값과는 무관하게 결과 값은 항상 일정<br>

- 최악의 경우 분석(Worst-case analysis)<br>
단위 연산이 수행되는 횟수가 최대인 경우 선택<br>

- 평균의 경우 분석(Average-case analysis)<br>
모든 입력에 대해서 단위 연산이 수행되는 기대치(평균)/ 최악의 경우보다 계산 복잡<br>

- 최선의 경우 분석(Best-case analysis)<br>
단위 연산이 수행되는 횟수가 최소인 경우 선택<br><br>
**우리의 관심은 Worst-case Analysis**<br>

## 배열의 수 더하기
```python
def sum(n, S):
  result = 0
  for i in range(n):
    result += S[i]
  return result
```
단위 연산: 덧셈 ⇒ T(n) = n<br>
단위 연산: 지정문(for의 `첨자 지정문 포함`) ⇒ T(n) = n + n + 1<br>

## 교환 정렬
```python
def exchangesort(n, S):
  for i in range(0,n-1):
    for j in range(i+1,n):
      if(S[j] < S[i]):
        temp = S[i]
        S[i] = S[j]
        S[j] = temp
```

## 교환 정렬의 시간 복잡도 분석(1)
단위 연산: 조건문<br>
T(n)= n − 1 + n − 2 + … + 1 = (n-1)n / 2<br>

## 교환 정렬의 시간 복잡도 분석(2)
단위 연산: 교환하는 연산<br>
**최악의 경우** 분석: 조건문이 항상 참이 되는 경우 = 입력 배열이 거꾸로 정렬되어 있는 경우<br>
W(n) = (n-1)n / 2<br>

## 행렬곱셈 시간복잡도 분석
단위 연산: 가장 안쪽 for 루프에 있는 곱셈<br>
**모든 경우** 분석: T(n) = n * n * n = n^3<br>

## 순차검색 시간복잡도 분석(최악)
단위 연산: 비교 연산<br>
배열의 마지막 아이템이거나, 배열에 없는 경우<br>
W(n) = n<br>
**순차검색 알고리즘의 경우 입력배열의 값에 따라서
검색하는 횟수가 달라지므로, 모든 경우 분석은 불가능**

## 순차검색 시간복잡도 분석(평균)
단위 연산: 비교 연산<br>
`경우 1` x가 배열 안에 있는 경우만 고려<br>
A(n) = (n+1)/2<br>
`경우 2` x가 배열 안에 없는 경우도 고려<br>
A(n) = n(1-p/2) + p/2<br>

## 순차검색 시간복잡도 분석(최선)
단위 연산: 비교 연산<br>
입력의 크기 상관없이 단위 연산이 1번만 수행<br>
B(n) = 1<br>










